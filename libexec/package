#!/bin/sh

dependency_to_package_name() (
  dependency_to_package_name_and_space_and_version $1 | awk '{print $1}'
)

dependency_to_package_version() (
  dependency_to_package_name_and_space_and_version $1 | awk '{print $2}'
)

dependency_to_package_name_and_version() (
  dependency_to_package_name_and_space_and_version $1 | awk '{if ($2) { print $1"-"$2} else { print $1 }}'
)

dependency_to_package_name_and_space_and_version() (
  NAWK 'BEGIN {
    dep = ARGV[1]
    sub(/^builtin_/, "", dep)
    len = split(dep, dep_words, "-")
    printf dep_words[1]
    if (len == 1) {
      exit
    }
    for (a = 2; a <= len; a++) {
      dep_word = dep_words[a]
      if (match(dep_word, /^[0-9]+(\.[0-9]+)*$/)) {
        printf " " dep_word
        exit
      } else {
        printf "-" dep_word
      }
    }
  }' $1
)

dependencies_to_package_name_and_version() (
  if [ $1 = "depends:" ]; then
    shift
  fi
  output=
  for dep in $*; do
    output="$output `dependency_to_package_name_and_version $dep`"
  done
  echo $output
)

max_package_version() (
  NAWK 'BEGIN {
    for (a = 1; a <= ARGC; a++) {
      str = ARGV[a]
      values_length = split(str, values, ".")
      if (!match(str, /^[0-9]+(\.[0-9]+)*$/)) {
        continue
      }
      max_values_length = split(max_str, max_values, ".")
      for (b = 1; b <= values_length; b++) {
        if (b > max_values_length || values[b] > max_values[b] + 0) {
          max_str = str
          break
        } else if (values[b] + 0 < max_values[b] + 0) {
          break
        }
      }
    }
    printf max_str
  }' $*
)

ghc_pkg_version() (
  echo $1 | sed 's/^.* //'
)
