#!/bin/sh

dependency_to_package_name() {
  dependency_to_package_name_and_space_and_version $1 | awk '{print $1}'
}

dependency_to_package_version() {
  dependency_to_package_name_and_space_and_version $1 | awk '{print $2}'
}

dependency_to_package_name_and_version() {
  dependency_to_package_name_and_space_and_version $1 | awk '{if ($2) { print $1"-"$2} else { print $1 }}'
}

dependency_to_package_name_and_space_and_version() {
  awk 'BEGIN {
    dep = ARGV[1]
    sub(/^builtin_/, "", dep)
    len = split(dep, dep_words, "-")
    printf dep_words[1]
    if (len == 1) {
      exit
    }
    for (a = 2; a <= len; a++) {
      dep_word = dep_words[a]
      split(dep_word, nums, ".")
      is_version = 1
      for (b = 1; b <= length(nums); b++) {
        num = nums[b]
        if (!match(num, /^[0-9]+$/)) {
          is_version = 0
          break
        }
      }
      if (is_version) {
        printf " " dep_word
        exit
      } else {
        printf "-" dep_word
      }
    }
  }' $1
}

dependencies_to_package_name_and_version() {
  if [ $1 = "depends:" ]; then
    shift
  fi
  output=
  for dep in $*; do
    output="$output `dependency_to_package_name_and_version $dep`"
  done
  echo $output
}

max_package_version() {
  awk 'BEGIN {
    for (a = 1; a <= ARGC; a++) {
      str = ARGV[a]

      values_length = split(str, values, ".")
      is_version = 1
      for (b = 1; b <= values_length; b++) {
        value = values[b]
        if (!match(value, /^[0-9]+$/)) {
          is_version = 0
          break
        }
      }
      if (!is_version) {
        continue
      }

      max_values_length = split(max_str, max_values, ".")
      for (b = 1; b <= values_length; b++) {
        if (b > max_values_length || values[b] > max_values[b] + 0) {
          max_str = str
          break
        } else if (values[b] + 0 < max_values[b] + 0) {
          break
        }
      }
    }
    printf max_str
  }' $*
}
